{"ast":null,"code":"var _jsxFileName = \"/Users/lawrence_wakefield/Documents/Development/codeworks/final-project/blogging-platform/next/components/private_route.tsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport { AuthToken } from '../services/auth_token';\nexport function privateRoute(WrappedComponent) {\n  var _temp;\n\n  return _temp = class extends Component {\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty(this, \"state\", {\n        auth: new AuthToken(this.props.token)\n      });\n    }\n\n    static async getInitialProps(ctx) {\n      // create AuthToken\n      const auth = AuthToken.fromNext(ctx);\n      const initialProps = {\n        auth\n      }; // if the token is expired, that means the user is no longer (or never was) authenticated\n      // and if we allow the request to continue, they will reach a page they should not be at.\n\n      if (auth.isExpired) console.log(\"hey! server says you shouldnt be here! you are not logged in!\");\n\n      if (WrappedComponent.getInitialProps) {\n        const wrappedProps = await WrappedComponent.getInitialProps(initialProps); // make sure our `auth: AuthToken` is always returned\n\n        return _objectSpread({}, wrappedProps, {\n          auth\n        });\n      }\n\n      return initialProps;\n    }\n\n    componentDidMount() {\n      // since getInitialProps returns our props after they've JSON.stringify\n      // we need to reinitialize it as an AuthToken to have the full class\n      // with all instance methods available\n      this.setState({\n        auth: new AuthToken(this.props.token)\n      });\n    }\n\n    render() {\n      // we want to hydrate the WrappedComponent with a full instance method of\n      // AuthToken, the existing props.auth is a flattened auth, we want to use\n      // the state instance of auth that has been rehydrated in browser after mount\n      const _this$props = this.props,\n            {\n        auth\n      } = _this$props,\n            propsWithoutAuth = _objectWithoutProperties(_this$props, [\"auth\"]);\n\n      return __jsx(WrappedComponent, _extends({\n        auth: this.state.auth\n      }, propsWithoutAuth, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 43,\n          columnNumber: 14\n        }\n      }));\n    }\n\n  }, _temp;\n}","map":{"version":3,"sources":["/Users/lawrence_wakefield/Documents/Development/codeworks/final-project/blogging-platform/next/components/private_route.tsx"],"names":["React","Component","AuthToken","privateRoute","WrappedComponent","auth","props","token","getInitialProps","ctx","fromNext","initialProps","isExpired","console","log","wrappedProps","componentDidMount","setState","render","propsWithoutAuth","state"],"mappings":";;;;;;;;;;;;;;;AACA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,SAAT,QAA0B,wBAA1B;AAOA,OAAO,SAASC,YAAT,CAAsBC,gBAAtB,EAA6C;AAAA;;AAClD,iBAAO,cAAcH,SAAd,CAAmC;AAAA;AAAA;;AAAA,qCAChC;AACNI,QAAAA,IAAI,EAAE,IAAIH,SAAJ,CAAc,KAAKI,KAAL,CAAWC,KAAzB;AADA,OADgC;AAAA;;AAKxC,iBAAaC,eAAb,CAA6BC,GAA7B,EAAmD;AACjD;AACA,YAAMJ,IAAI,GAAGH,SAAS,CAACQ,QAAV,CAAmBD,GAAnB,CAAb;AACA,YAAME,YAAY,GAAG;AAAEN,QAAAA;AAAF,OAArB,CAHiD,CAIjD;AACA;;AACA,UAAIA,IAAI,CAACO,SAAT,EAAoBC,OAAO,CAACC,GAAR,CAAY,+DAAZ;;AACpB,UAAIV,gBAAgB,CAACI,eAArB,EAAsC;AACpC,cAAMO,YAAY,GAAG,MAAMX,gBAAgB,CAACI,eAAjB,CAAiCG,YAAjC,CAA3B,CADoC,CAEpC;;AACA,iCAAYI,YAAZ;AAA0BV,UAAAA;AAA1B;AACD;;AACD,aAAOM,YAAP;AACD;;AAEDK,IAAAA,iBAAiB,GAAS;AACxB;AACA;AACA;AACA,WAAKC,QAAL,CAAc;AAAEZ,QAAAA,IAAI,EAAE,IAAIH,SAAJ,CAAc,KAAKI,KAAL,CAAWC,KAAzB;AAAR,OAAd;AACD;;AAEDW,IAAAA,MAAM,GAAG;AACP;AACA;AACA;AACA,0BAAsC,KAAKZ,KAA3C;AAAA,YAAM;AAAED,QAAAA;AAAF,OAAN;AAAA,YAAiBc,gBAAjB;;AACA,aAAO,MAAC,gBAAD;AAAkB,QAAA,IAAI,EAAE,KAAKC,KAAL,CAAWf;AAAnC,SAA6Cc,gBAA7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAP;AACD;;AAjCuC,GAA1C;AAmCD","sourcesContent":["import { NextPageContext } from 'next';\nimport React, { Component } from 'react';\nimport { AuthToken } from '../services/auth_token';\nimport { redirectToLogin } from '../services/redirect_service';\n\nexport type AuthProps = {\n  token: string\n}\n\nexport function privateRoute(WrappedComponent: any) {\n  return class extends Component<AuthProps> {\n    state = {\n      auth: new AuthToken(this.props.token)\n    };\n\n    static async getInitialProps(ctx: NextPageContext) {\n      // create AuthToken\n      const auth = AuthToken.fromNext(ctx);\n      const initialProps = { auth };\n      // if the token is expired, that means the user is no longer (or never was) authenticated\n      // and if we allow the request to continue, they will reach a page they should not be at.\n      if (auth.isExpired) console.log(\"hey! server says you shouldnt be here! you are not logged in!\");\n      if (WrappedComponent.getInitialProps) {\n        const wrappedProps = await WrappedComponent.getInitialProps(initialProps);\n        // make sure our `auth: AuthToken` is always returned\n        return { ...wrappedProps, auth };\n      }\n      return initialProps;\n    }\n\n    componentDidMount(): void {\n      // since getInitialProps returns our props after they've JSON.stringify\n      // we need to reinitialize it as an AuthToken to have the full class\n      // with all instance methods available\n      this.setState({ auth: new AuthToken(this.props.token) })\n    }\n\n    render() {\n      // we want to hydrate the WrappedComponent with a full instance method of\n      // AuthToken, the existing props.auth is a flattened auth, we want to use\n      // the state instance of auth that has been rehydrated in browser after mount\n      const { auth, ...propsWithoutAuth } = this.props;\n      return <WrappedComponent auth={this.state.auth} {...propsWithoutAuth} />;\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}