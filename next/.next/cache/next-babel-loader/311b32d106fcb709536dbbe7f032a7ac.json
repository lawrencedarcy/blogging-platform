{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/Users/lawrence_wakefield/Documents/Development/codeworks/final-project/blogging-platform/next/components/private_route.tsx\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport { AuthToken } from '../services/auth_token';\nexport function privateRoute(WrappedComponent) {\n  var _temp;\n\n  return _temp = /*#__PURE__*/function (_Component) {\n    _inherits(_temp, _Component);\n\n    var _super = _createSuper(_temp);\n\n    function _temp() {\n      var _this;\n\n      _classCallCheck(this, _temp);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n\n      _defineProperty(_assertThisInitialized(_this), \"state\", {\n        auth: new AuthToken(_this.props.token)\n      });\n\n      return _this;\n    }\n\n    _createClass(_temp, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        // since getInitialProps returns our props after they've JSON.stringify\n        // we need to reinitialize it as an AuthToken to have the full class\n        // with all instance methods available\n        this.setState({\n          auth: new AuthToken(this.props.token)\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        // we want to hydrate the WrappedComponent with a full instance method of\n        // AuthToken, the existing props.auth is a flattened auth, we want to use\n        // the state instance of auth that has been rehydrated in browser after mount\n        var _this$props = this.props,\n            auth = _this$props.auth,\n            propsWithoutAuth = _objectWithoutProperties(_this$props, [\"auth\"]);\n\n        return __jsx(WrappedComponent, _extends({\n          auth: this.state.auth\n        }, propsWithoutAuth, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 43,\n            columnNumber: 14\n          }\n        }));\n      }\n    }], [{\n      key: \"getInitialProps\",\n      value: function getInitialProps(ctx) {\n        var auth, initialProps, wrappedProps;\n        return _regeneratorRuntime.async(function getInitialProps$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // create AuthToken\n                auth = AuthToken.fromNext(ctx);\n                initialProps = {\n                  auth: auth\n                }; // if the token is expired, that means the user is no longer (or never was) authenticated\n                // and if we allow the request to continue, they will reach a page they should not be at.\n\n                if (auth.isExpired) console.log(\"hey! server says you shouldnt be here! you are not logged in!\");\n\n                if (!WrappedComponent.getInitialProps) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 6;\n                return _regeneratorRuntime.awrap(WrappedComponent.getInitialProps(initialProps));\n\n              case 6:\n                wrappedProps = _context.sent;\n                return _context.abrupt(\"return\", _objectSpread({}, wrappedProps, {\n                  auth: auth\n                }));\n\n              case 8:\n                return _context.abrupt(\"return\", initialProps);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      }\n    }]);\n\n    return _temp;\n  }(Component), _temp;\n}","map":{"version":3,"sources":["/Users/lawrence_wakefield/Documents/Development/codeworks/final-project/blogging-platform/next/components/private_route.tsx"],"names":["React","Component","AuthToken","privateRoute","WrappedComponent","auth","props","token","setState","propsWithoutAuth","state","ctx","fromNext","initialProps","isExpired","console","log","getInitialProps","wrappedProps"],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,SAAT,QAA0B,wBAA1B;AAOA,OAAO,SAASC,YAAT,CAAsBC,gBAAtB,EAA6C;AAAA;;AAClD;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA,8DACU;AACNC,QAAAA,IAAI,EAAE,IAAIH,SAAJ,CAAc,MAAKI,KAAL,CAAWC,KAAzB;AADA,OADV;;AAAA;AAAA;;AAAA;AAAA;AAAA,0CAoB4B;AACxB;AACA;AACA;AACA,aAAKC,QAAL,CAAc;AAAEH,UAAAA,IAAI,EAAE,IAAIH,SAAJ,CAAc,KAAKI,KAAL,CAAWC,KAAzB;AAAR,SAAd;AACD;AAzBH;AAAA;AAAA,+BA2BW;AACP;AACA;AACA;AAHO,0BAI+B,KAAKD,KAJpC;AAAA,YAICD,IAJD,eAICA,IAJD;AAAA,YAIUI,gBAJV;;AAKP,eAAO,MAAC,gBAAD;AAAkB,UAAA,IAAI,EAAE,KAAKC,KAAL,CAAWL;AAAnC,WAA6CI,gBAA7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAP;AACD;AAjCH;AAAA;AAAA,sCAK+BE,GAL/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAMI;AACMN,gBAAAA,IAPV,GAOiBH,SAAS,CAACU,QAAV,CAAmBD,GAAnB,CAPjB;AAQUE,gBAAAA,YARV,GAQyB;AAAER,kBAAAA,IAAI,EAAJA;AAAF,iBARzB,EASI;AACA;;AACA,oBAAIA,IAAI,CAACS,SAAT,EAAoBC,OAAO,CAACC,GAAR,CAAY,+DAAZ;;AAXxB,qBAYQZ,gBAAgB,CAACa,eAZzB;AAAA;AAAA;AAAA;;AAAA;AAAA,iDAaiCb,gBAAgB,CAACa,eAAjB,CAAiCJ,YAAjC,CAbjC;;AAAA;AAaYK,gBAAAA,YAbZ;AAAA,mEAekBA,YAflB;AAegCb,kBAAAA,IAAI,EAAJA;AAfhC;;AAAA;AAAA,iDAiBWQ,YAjBX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,IAAqBZ,SAArB;AAmCD","sourcesContent":["import { NextPageContext } from 'next';\nimport React, { Component } from 'react';\nimport { AuthToken } from '../services/auth_token';\nimport { redirectToLogin } from '../services/redirect_service';\n\nexport type AuthProps = {\n  token: string\n}\n\nexport function privateRoute(WrappedComponent: any) {\n  return class extends Component<AuthProps> {\n    state = {\n      auth: new AuthToken(this.props.token)\n    };\n\n    static async getInitialProps(ctx: NextPageContext) {\n      // create AuthToken\n      const auth = AuthToken.fromNext(ctx);\n      const initialProps = { auth };\n      // if the token is expired, that means the user is no longer (or never was) authenticated\n      // and if we allow the request to continue, they will reach a page they should not be at.\n      if (auth.isExpired) console.log(\"hey! server says you shouldnt be here! you are not logged in!\");\n      if (WrappedComponent.getInitialProps) {\n        const wrappedProps = await WrappedComponent.getInitialProps(initialProps);\n        // make sure our `auth: AuthToken` is always returned\n        return { ...wrappedProps, auth };\n      }\n      return initialProps;\n    }\n\n    componentDidMount(): void {\n      // since getInitialProps returns our props after they've JSON.stringify\n      // we need to reinitialize it as an AuthToken to have the full class\n      // with all instance methods available\n      this.setState({ auth: new AuthToken(this.props.token) })\n    }\n\n    render() {\n      // we want to hydrate the WrappedComponent with a full instance method of\n      // AuthToken, the existing props.auth is a flattened auth, we want to use\n      // the state instance of auth that has been rehydrated in browser after mount\n      const { auth, ...propsWithoutAuth } = this.props;\n      return <WrappedComponent auth={this.state.auth} {...propsWithoutAuth} />;\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}