{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport jwtDecode from 'jwt-decode';\nimport Cookie from 'js-cookie';\nexport class AuthToken {\n  constructor(token) {\n    this.token = token;\n\n    _defineProperty(this, \"decodedToken\", void 0);\n\n    // we are going to default to an expired decodedToken\n    this.decodedToken = {\n      email: \"\",\n      exp: 0\n    }; // then try and decode the jwt using jwt-decode\n\n    try {\n      if (token) this.decodedToken = jwtDecode(token);\n    } catch (e) {}\n  }\n\n  get authorizationString() {\n    return `Bearer ${this.token}`;\n  }\n\n  get expiresAt() {\n    return new Date(this.decodedToken.exp * 1000);\n  }\n\n  get isExpired() {\n    return new Date() > this.expiresAt;\n  }\n\n  get isValid() {\n    return !this.isExpired;\n  }\n\n  static async storeToken(token) {\n    Cookie.set(TOKEN_STORAGE_KEY, token);\n    await Router.push(\"/dashboard\");\n  }\n\n}","map":{"version":3,"sources":["/Users/lawrence_wakefield/Documents/Development/codeworks/final-project/blogging-platform/next/services/auth_token.ts"],"names":["jwtDecode","Cookie","AuthToken","constructor","token","decodedToken","email","exp","e","authorizationString","expiresAt","Date","isExpired","isValid","storeToken","set","TOKEN_STORAGE_KEY","Router","push"],"mappings":";;AAAA,OAAOA,SAAP,MAAsB,YAAtB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AAOA,OAAO,MAAMC,SAAN,CAAgB;AAGrBC,EAAAA,WAAW,CAAUC,KAAV,EAA0B;AAAA,SAAhBA,KAAgB,GAAhBA,KAAgB;;AAAA;;AACnC;AACA,SAAKC,YAAL,GAAoB;AAAEC,MAAAA,KAAK,EAAE,EAAT;AAAaC,MAAAA,GAAG,EAAE;AAAlB,KAApB,CAFmC,CAInC;;AACA,QAAI;AACF,UAAIH,KAAJ,EAAW,KAAKC,YAAL,GAAoBL,SAAS,CAACI,KAAD,CAA7B;AACZ,KAFD,CAEE,OAAOI,CAAP,EAAU,CACX;AACF;;AAED,MAAIC,mBAAJ,GAA0B;AACxB,WAAQ,UAAS,KAAKL,KAAM,EAA5B;AACD;;AAED,MAAIM,SAAJ,GAAsB;AACpB,WAAO,IAAIC,IAAJ,CAAS,KAAKN,YAAL,CAAkBE,GAAlB,GAAwB,IAAjC,CAAP;AACD;;AAED,MAAIK,SAAJ,GAAyB;AACvB,WAAO,IAAID,IAAJ,KAAa,KAAKD,SAAzB;AACD;;AAED,MAAIG,OAAJ,GAAuB;AACrB,WAAO,CAAC,KAAKD,SAAb;AACD;;AAED,eAAaE,UAAb,CAAwBV,KAAxB,EAAuC;AACrCH,IAAAA,MAAM,CAACc,GAAP,CAAWC,iBAAX,EAA8BZ,KAA9B;AACA,UAAMa,MAAM,CAACC,IAAP,CAAY,YAAZ,CAAN;AACD;;AAjCoB","sourcesContent":["import jwtDecode from 'jwt-decode';\nimport Cookie from 'js-cookie';\n\nexport type DecodedToken = {\n  readonly email: string;\n  readonly exp: number;\n}\n\nexport class AuthToken {\n  readonly decodedToken: DecodedToken;\n\n  constructor(readonly token?: string) {\n    // we are going to default to an expired decodedToken\n    this.decodedToken = { email: \"\", exp: 0 };\n\n    // then try and decode the jwt using jwt-decode\n    try {\n      if (token) this.decodedToken = jwtDecode(token);\n    } catch (e) {\n    }\n  }\n\n  get authorizationString() {\n    return `Bearer ${this.token}`;\n  }\n\n  get expiresAt(): Date {\n    return new Date(this.decodedToken.exp * 1000);\n  }\n\n  get isExpired(): boolean {\n    return new Date() > this.expiresAt;\n  }\n\n  get isValid(): boolean {\n    return !this.isExpired;\n  }\n\n  static async storeToken(token: string) {\n    Cookie.set(TOKEN_STORAGE_KEY, token);\n    await Router.push(\"/dashboard\");\n  }\n}"]},"metadata":{},"sourceType":"module"}